!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("three")):"function"==typeof define&&define.amd?define("potree",["three"],e):"object"==typeof exports?exports.potree=e(require("three")):t.potree=e(t.three)}(self,(function(t){return(()=>{"use strict";var e={689:(t,e)=>{function i(t){this.content=[],this.scoreFunction=t}e.L=i,i.prototype={push:function(t){this.content.push(t),this.bubbleUp(this.content.length-1)},pop:function(){var t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.sinkDown(0)),t},remove:function(t){for(var e=this.content.length,i=0;i<e;i++)if(this.content[i]==t){var n=this.content.pop();if(i==e-1)break;this.content[i]=n,this.bubbleUp(i),this.sinkDown(i);break}},size:function(){return this.content.length},bubbleUp:function(t){for(var e=this.content[t],i=this.scoreFunction(e);t>0;){var n=Math.floor((t+1)/2)-1,o=this.content[n];if(i>=this.scoreFunction(o))break;this.content[n]=e,this.content[t]=o,t=n}},sinkDown:function(t){for(var e=this.content.length,i=this.content[t],n=this.scoreFunction(i);;){var o=2*(t+1),r=o-1,s=null;if(r<e){var a=this.content[r],l=this.scoreFunction(a);l<n&&(s=r)}if(o<e){var d=this.content[o];this.scoreFunction(d)<(null==s?n:l)&&(s=o)}if(null==s)break;this.content[t]=this.content[s],this.content[s]=i,t=s}}}},913:(t,e,i)=>{i.r(e),i.d(e,{default:()=>n});const n="precision highp float;\nprecision highp int;\n\nuniform mat4 projectionMatrix;\n\nuniform float screenWidth;\nuniform float screenHeight;\n\nuniform sampler2D map;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tfloat dx = 1.0 / screenWidth;\n\tfloat dy = 1.0 / screenHeight;\n\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += texture2D(map, vUv + vec2(-dx, -dy)).rgb;\n\tcolor += texture2D(map, vUv + vec2(  0, -dy)).rgb;\n\tcolor += texture2D(map, vUv + vec2(+dx, -dy)).rgb;\n\tcolor += texture2D(map, vUv + vec2(-dx,   0)).rgb;\n\tcolor += texture2D(map, vUv + vec2(  0,   0)).rgb;\n\tcolor += texture2D(map, vUv + vec2(+dx,   0)).rgb;\n\tcolor += texture2D(map, vUv + vec2(-dx,  dy)).rgb;\n\tcolor += texture2D(map, vUv + vec2(  0,  dy)).rgb;\n\tcolor += texture2D(map, vUv + vec2(+dx,  dy)).rgb;\n    \n\tcolor = color / 9.0;\n\t\n\tgl_FragColor = vec4(color, 1.0);\n\t\n\t\n}"},412:(t,e,i)=>{i.r(e),i.d(e,{default:()=>n});const n="precision highp float;\nprecision highp int;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n\n    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"},53:(t,e,i)=>{i.d(e,{Z:()=>n});const n="precision highp float;\nprecision highp int;\n\n#if defined paraboloid_point_shape\n\t#extension GL_EXT_frag_depth : enable\n#endif\n\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n\nuniform mat4 projectionMatrix;\nuniform float opacity;\n\nuniform float blendHardness;\nuniform float blendDepthSupplement;\nuniform float fov;\nuniform float spacing;\nuniform float pcIndex;\nuniform float screenWidth;\nuniform float screenHeight;\n\nuniform sampler2D depthMap;\n\n#ifdef highlight_point\n\tuniform vec4 highlightedPointColor;\n#endif\n\nvarying vec3 vColor;\n\n#if !defined(color_type_point_index)\n\tvarying float vOpacity;\n#endif\n\n#if defined(weighted_splats)\n\tvarying float vLinearDepth;\n#endif\n\n#if !defined(paraboloid_point_shape) && defined(use_edl)\n\tvarying float vLogDepth;\n#endif\n\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\n\tvarying vec3 vViewPosition;\n#endif\n\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\n\tvarying float vRadius;\n#endif\n\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\n\tvarying vec3 vNormal;\n#endif\n\n#ifdef highlight_point\n\tvarying float vHighlight;\n#endif\n\nfloat specularStrength = 1.0;\n\nvoid main() {\n\tvec3 color = vColor;\n\tfloat depth = gl_FragCoord.z;\n\n\t#if defined(circle_point_shape) || defined(paraboloid_point_shape) || defined (weighted_splats)\n\t\tfloat u = 2.0 * gl_PointCoord.x - 1.0;\n\t\tfloat v = 2.0 * gl_PointCoord.y - 1.0;\n\t#endif\n\t\n\t#if defined(circle_point_shape) || defined (weighted_splats)\n\t\tfloat cc = u*u + v*v;\n\t\tif(cc > 1.0){\n\t\t\tdiscard;\n\t\t}\n\t#endif\n\n\t#if defined weighted_splats\n\t\tvec2 uv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\n\t\tfloat sDepth = texture2D(depthMap, uv).r;\n\t\tif(vLinearDepth > sDepth + vRadius + blendDepthSupplement){\n\t\t\tdiscard;\n\t\t}\n\t#endif\n\t\t\n\t#if defined color_type_point_index\n\t\tgl_FragColor = vec4(color, pcIndex / 255.0);\n\t#else\n\t\tgl_FragColor = vec4(color, vOpacity);\n\t#endif\n\n\t#if defined(color_type_phong)\n\t\t#if MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0\n\t\t\tvec3 normal = normalize( vNormal );\n\t\t\tnormal.z = abs(normal.z);\n\n\t\t\tvec3 viewPosition = normalize( vViewPosition );\n\t\t#endif\n\n\t\t// code taken from three.js phong light fragment shader\n\t\n\t\t#if MAX_POINT_LIGHTS > 0\n\n\t\t\tvec3 pointDiffuse = vec3( 0.0 );\n\t\t\tvec3 pointSpecular = vec3( 0.0 );\n\n\t\t\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\t\t\tfloat lDistance = 1.0;\n\t\t\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n\t\t\t\tlVector = normalize( lVector );\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t\t#else\n\n\t\t\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t\t#endif\n\n\t\t\t\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n\t\t\t\t// specular\n\n\t\t\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\t\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\t\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\t\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\t\t\t\tpointSpecular = vec3(0.0, 0.0, 0.0);\n\t\t\t}\n\t\t\n\t\t#endif\n\t\t\n\t\t#if MAX_DIR_LIGHTS > 0\n\n\t\t\tvec3 dirDiffuse = vec3( 0.0 );\n\t\t\tvec3 dirSpecular = vec3( 0.0 );\n\n\t\t\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\t\t\tvec3 dirVector = normalize( lDirection.xyz );\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\tfloat dotProduct = dot( normal, dirVector );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t\t#else\n\n\t\t\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t\t#endif\n\n\t\t\t\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n\t\t\t\t// specular\n\n\t\t\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\t\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\t\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\t\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\t\t\t}\n\n\t\t#endif\n\t\t\n\t\tvec3 totalDiffuse = vec3( 0.0 );\n\t\tvec3 totalSpecular = vec3( 0.0 );\n\t\t\n\t\t#if MAX_POINT_LIGHTS > 0\n\n\t\t\ttotalDiffuse += pointDiffuse;\n\t\t\ttotalSpecular += pointSpecular;\n\n\t\t#endif\n\t\t\n\t\t#if MAX_DIR_LIGHTS > 0\n\n\t\t\ttotalDiffuse += dirDiffuse;\n\t\t\ttotalSpecular += dirSpecular;\n\n\t\t#endif\n\t\t\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n\t#endif\n\t\n\t#if defined weighted_splats\n\t    //float w = pow(1.0 - (u*u + v*v), blendHardness);\n\t\t\n\t\tfloat wx = 2.0 * length(2.0 * gl_PointCoord - 1.0);\n\t\tfloat w = exp(-wx * wx * 0.5);\n\t\t\n\t\t//float distance = length(2.0 * gl_PointCoord - 1.0);\n\t\t//float w = exp( -(distance * distance) / blendHardness);\n\t\t\n\t\tgl_FragColor.rgb = gl_FragColor.rgb * w;\n\t\tgl_FragColor.a = w;\n\t#endif\n\t\n\t#if defined paraboloid_point_shape\n\t\tfloat wi = 0.0 - ( u*u + v*v);\n\t\tvec4 pos = vec4(vViewPosition, 1.0);\n\t\tpos.z += wi * vRadius;\n\t\tfloat linearDepth = -pos.z;\n\t\tpos = projectionMatrix * pos;\n\t\tpos = pos / pos.w;\n\t\tfloat expDepth = pos.z;\n\t\tdepth = (pos.z + 1.0) / 2.0;\n\t\tgl_FragDepthEXT = depth;\n\t\t\n\t\t#if defined(color_type_depth)\n\t\t\tgl_FragColor.r = linearDepth;\n\t\t\tgl_FragColor.g = expDepth;\n\t\t#endif\n\t\t\n\t\t#if defined(use_edl)\n\t\t\tgl_FragColor.a = log2(linearDepth);\n\t\t#endif\n\t\t\n\t#else\n\t\t#if defined(use_edl)\n\t\t\tgl_FragColor.a = vLogDepth;\n\t\t#endif\n\t#endif\n\n\t#ifdef highlight_point\n\t\tif (vHighlight > 0.0) {\n\t\t\tgl_FragColor = highlightedPointColor;\n\t\t}\n\t#endif\n}\n"},59:(t,e,i)=>{i.d(e,{Z:()=>n});const n="precision highp float;\nprecision highp int;\n\n#define max_clip_boxes 30\n\nattribute vec3 position;\nattribute vec3 color;\nattribute vec3 normal;\nattribute float intensity;\nattribute float classification;\nattribute float returnNumber;\nattribute float numberOfReturns;\nattribute float pointSourceID;\nattribute vec4 indices;\n\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\n\nuniform float pcIndex;\n\nuniform float screenWidth;\nuniform float screenHeight;\nuniform float fov;\nuniform float spacing;\n\n#if defined use_clip_box\n\tuniform mat4 clipBoxes[max_clip_boxes];\n#endif\n\n#if NUM_CLIP_PLANES > 0\n\tuniform vec4 clippingPlanes[NUM_CLIP_PLANES];\n#endif\n\nuniform float heightMin;\nuniform float heightMax;\nuniform float size; // pixel size factor\nuniform float minSize; // minimum pixel size\nuniform float maxSize; // maximum pixel size\nuniform float octreeSize;\nuniform vec3 bbSize;\nuniform vec3 uColor;\nuniform float opacity;\nuniform float clipBoxCount;\nuniform float level;\nuniform float vnStart;\nuniform bool isLeafNode;\n\nuniform float filterByNormalThreshold;\nuniform vec2 intensityRange;\nuniform float opacityAttenuation;\nuniform float intensityGamma;\nuniform float intensityContrast;\nuniform float intensityBrightness;\nuniform float rgbGamma;\nuniform float rgbContrast;\nuniform float rgbBrightness;\nuniform float transition;\nuniform float wRGB;\nuniform float wIntensity;\nuniform float wElevation;\nuniform float wClassification;\nuniform float wReturnNumber;\nuniform float wSourceID;\n\nuniform sampler2D visibleNodes;\nuniform sampler2D gradient;\nuniform sampler2D classificationLUT;\nuniform sampler2D depthMap;\n\n#ifdef highlight_point\n\tuniform vec3 highlightedPointCoordinate;\n\tuniform bool enablePointHighlighting;\n\tuniform float highlightedPointScale;\n#endif\n\nvarying vec3 vColor;\n\n#if !defined(color_type_point_index)\n\tvarying float vOpacity;\n#endif\n\n#if defined(weighted_splats)\n\tvarying float vLinearDepth;\n#endif\n\n#if !defined(paraboloid_point_shape) && defined(use_edl)\n\tvarying float vLogDepth;\n#endif\n\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\n\tvarying vec3 vViewPosition;\n#endif\n\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\n\tvarying float vRadius;\n#endif\n\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\n\tvarying vec3 vNormal;\n#endif\n\n#ifdef highlight_point\n\tvarying float vHighlight;\n#endif\n\n// ---------------------\n// OCTREE\n// ---------------------\n\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_octree)\n\n/**\n * Rounds the specified number to the closest integer.\n */\nfloat round(float number){\n\treturn floor(number + 0.5);\n}\n\n/**\n * Gets the number of 1-bits up to inclusive index position.\n *\n * number is treated as if it were an integer in the range 0-255\n */\nint numberOfOnes(int number, int index) {\n\tint numOnes = 0;\n\tint tmp = 128;\n\tfor (int i = 7; i >= 0; i--) {\n\n\t\tif (number >= tmp) {\n\t\t\tnumber = number - tmp;\n\n\t\t\tif (i <= index) {\n\t\t\t\tnumOnes++;\n\t\t\t}\n\t\t}\n\n\t\ttmp = tmp / 2;\n\t}\n\n\treturn numOnes;\n}\n\n/**\n * Checks whether the bit at index is 1.0\n *\n * number is treated as if it were an integer in the range 0-255\n */\nbool isBitSet(int number, int index){\n\n\t// weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\n\tint powi = 1;\n\tif (index == 0) {\n\t\tpowi = 1;\n\t} else if (index == 1) {\n\t\tpowi = 2;\n\t} else if (index == 2) {\n\t\tpowi = 4;\n\t} else if (index == 3) {\n\t\tpowi = 8;\n\t} else if (index == 4) {\n\t\tpowi = 16;\n\t} else if (index == 5) {\n\t\tpowi = 32;\n\t} else if (index == 6) {\n\t\tpowi = 64;\n\t} else if (index == 7) {\n\t\tpowi = 128;\n\t}\n\n\tint ndp = number / powi;\n\n\treturn mod(float(ndp), 2.0) != 0.0;\n}\n\n/**\n * Gets the the LOD at the point position.\n */\nfloat getLOD() {\n\tvec3 offset = vec3(0.0, 0.0, 0.0);\n\tint iOffset = int(vnStart);\n\tfloat depth = level;\n\n\tfor (float i = 0.0; i <= 30.0; i++) {\n\t\tfloat nodeSizeAtLevel = octreeSize  / pow(2.0, i + level + 0.0);\n\n\t\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\n\t\tindex3d = floor(index3d + 0.5);\n\t\tint index = int(round(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\n\n\t\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\n\t\tint mask = int(round(value.r * 255.0));\n\n\t\tif (isBitSet(mask, index)) {\n\t\t\t// there are more visible child nodes at this position\n\t\t\tint advanceG = int(round(value.g * 255.0)) * 256;\n\t\t\tint advanceB = int(round(value.b * 255.0));\n\t\t\tint advanceChild = numberOfOnes(mask, index - 1);\n\t\t\tint advance = advanceG + advanceB + advanceChild;\n\n\t\t\tiOffset = iOffset + advance;\n\n\t\t\tdepth++;\n\t\t} else {\n\t\t\treturn value.a * 255.0; // no more visible child nodes at this position\n\t\t}\n\n\t\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\n\t}\n\n\treturn depth;\n}\n\nfloat getPointSizeAttenuation() {\n\treturn 0.5 * pow(2.0, getLOD());\n}\n\n#endif\n\n// ---------------------\n// KD-TREE\n// ---------------------\n\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_kdtree)\n\nfloat getLOD() {\n\tvec3 offset = vec3(0.0, 0.0, 0.0);\n\tfloat intOffset = 0.0;\n\tfloat depth = 0.0;\n\n\tvec3 size = bbSize;\n\tvec3 pos = position;\n\n\tfor (float i = 0.0; i <= 1000.0; i++) {\n\n\t\tvec4 value = texture2D(visibleNodes, vec2(intOffset / 2048.0, 0.0));\n\n\t\tint children = int(value.r * 255.0);\n\t\tfloat next = value.g * 255.0;\n\t\tint split = int(value.b * 255.0);\n\n\t\tif (next == 0.0) {\n\t\t \treturn depth;\n\t\t}\n\n\t\tvec3 splitv = vec3(0.0, 0.0, 0.0);\n\t\tif (split == 1) {\n\t\t\tsplitv.x = 1.0;\n\t\t} else if (split == 2) {\n\t\t \tsplitv.y = 1.0;\n\t\t} else if (split == 4) {\n\t\t \tsplitv.z = 1.0;\n\t\t}\n\n\t\tintOffset = intOffset + next;\n\n\t\tfloat factor = length(pos * splitv / size);\n\t\tif (factor < 0.5) {\n\t\t \t// left\n\t\t\tif (children == 0 || children == 2) {\n\t\t\t\treturn depth;\n\t\t\t}\n\t\t} else {\n\t\t\t// right\n\t\t\tpos = pos - size * splitv * 0.5;\n\t\t\tif (children == 0 || children == 1) {\n\t\t\t\treturn depth;\n\t\t\t}\n\t\t\tif (children == 3) {\n\t\t\t\tintOffset = intOffset + 1.0;\n\t\t\t}\n\t\t}\n\t\tsize = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);\n\n\t\tdepth++;\n\t}\n\n\n\treturn depth;\n}\n\nfloat getPointSizeAttenuation() {\n\treturn 0.5 * pow(1.3, getLOD());\n}\n\n#endif\n\n// formula adapted from: http://www.dfstudios.co.uk/articles/programming/image-programming-algorithms/image-processing-algorithms-part-5-contrast-adjustment/\nfloat getContrastFactor(float contrast) {\n\treturn (1.0158730158730156 * (contrast + 1.0)) / (1.0158730158730156 - contrast);\n}\n\nvec3 getRGB() {\n\t#if defined(use_rgb_gamma_contrast_brightness)\n\t  vec3 rgb = color;\n\t\trgb = pow(rgb, vec3(rgbGamma));\n\t\trgb = rgb + rgbBrightness;\n\t\trgb = (rgb - 0.5) * getContrastFactor(rgbContrast) + 0.5;\n\t\trgb = clamp(rgb, 0.0, 1.0);\n\t\treturn rgb;\n\t#else\n\t\treturn color;\n\t#endif\n}\n\nfloat getIntensity() {\n\tfloat w = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\n\tw = pow(w, intensityGamma);\n\tw = w + intensityBrightness;\n\tw = (w - 0.5) * getContrastFactor(intensityContrast) + 0.5;\n\tw = clamp(w, 0.0, 1.0);\n\n\treturn w;\n}\n\nvec3 getElevation() {\n\tvec4 world = modelMatrix * vec4( position, 1.0 );\n\tfloat w = (world.z - heightMin) / (heightMax-heightMin);\n\tvec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n\treturn cElevation;\n}\n\nvec4 getClassification() {\n\tvec2 uv = vec2(classification / 255.0, 0.5);\n\tvec4 classColor = texture2D(classificationLUT, uv);\n\n\treturn classColor;\n}\n\nvec3 getReturnNumber() {\n\tif (numberOfReturns == 1.0) {\n\t\treturn vec3(1.0, 1.0, 0.0);\n\t} else {\n\t\tif (returnNumber == 1.0) {\n\t\t\treturn vec3(1.0, 0.0, 0.0);\n\t\t} else if (returnNumber == numberOfReturns) {\n\t\t\treturn vec3(0.0, 0.0, 1.0);\n\t\t} else {\n\t\t\treturn vec3(0.0, 1.0, 0.0);\n\t\t}\n\t}\n}\n\nvec3 getSourceID() {\n\tfloat w = mod(pointSourceID, 10.0) / 10.0;\n\treturn texture2D(gradient, vec2(w, 1.0 - w)).rgb;\n}\n\nvec3 getCompositeColor() {\n\tvec3 c;\n\tfloat w;\n\n\tc += wRGB * getRGB();\n\tw += wRGB;\n\n\tc += wIntensity * getIntensity() * vec3(1.0, 1.0, 1.0);\n\tw += wIntensity;\n\n\tc += wElevation * getElevation();\n\tw += wElevation;\n\n\tc += wReturnNumber * getReturnNumber();\n\tw += wReturnNumber;\n\n\tc += wSourceID * getSourceID();\n\tw += wSourceID;\n\n\tvec4 cl = wClassification * getClassification();\n\tc += cl.a * cl.rgb;\n\tw += wClassification * cl.a;\n\n\tc = c / w;\n\n\tif (w == 0.0) {\n\t\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\n\t}\n\n\treturn c;\n}\n\nvoid main() {\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\tvec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\n\t\tvViewPosition = mvPosition.xyz;\n\t#endif\n\n\t#if defined weighted_splats\n\t\tvLinearDepth = gl_Position.w;\n\t#endif\n\n\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\n\t\tvNormal = normalize(normalMatrix * normal);\n\t#endif\n\n\t#if !defined(paraboloid_point_shape) && defined(use_edl)\n\t\tvLogDepth = log2(-mvPosition.z);\n\t#endif\n\n\t// ---------------------\n\t// POINT SIZE\n\t// ---------------------\n\n\tfloat pointSize = 1.0;\n\tfloat slope = tan(fov / 2.0);\n\tfloat projFactor =  -0.5 * screenHeight / (slope * mvPosition.z);\n\n\t#if defined fixed_point_size\n\t\tpointSize = size;\n\t#elif defined attenuated_point_size\n\t\tpointSize = size * spacing * projFactor;\n\t#elif defined adaptive_point_size\n\t\tfloat worldSpaceSize = 2.0 * size * spacing / getPointSizeAttenuation();\n\t\tpointSize = worldSpaceSize * projFactor;\n\t#endif\n\n\tpointSize = max(minSize, pointSize);\n\tpointSize = min(maxSize, pointSize);\n\n\t#if defined(weighted_splats) || defined(paraboloid_point_shape)\n\t\tvRadius = pointSize / projFactor;\n\t#endif\n\n\tgl_PointSize = pointSize;\n\n\t// ---------------------\n\t// HIGHLIGHTING\n\t// ---------------------\n\n\t#ifdef highlight_point\n\t\tif (enablePointHighlighting && abs(mPosition.x - highlightedPointCoordinate.x) < 0.0001 &&\n\t\t\tabs(mPosition.y - highlightedPointCoordinate.y) < 0.0001 &&\n\t\t\tabs(mPosition.z - highlightedPointCoordinate.z) < 0.0001) {\n\t\t\tvHighlight = 1.0;\n\t\t\tgl_PointSize = pointSize * highlightedPointScale;\n\t\t} else {\n\t\t\tvHighlight = 0.0;\n\t\t}\n\t#endif\n\n\t// ---------------------\n\t// OPACITY\n\t// ---------------------\n\n\t#ifndef color_type_point_index\n\t\t#ifdef attenuated_opacity\n\t\t\tvOpacity = opacity * exp(-length(-mvPosition.xyz) / opacityAttenuation);\n\t\t#else\n\t\t\tvOpacity = opacity;\n\t\t#endif\n\t#endif\n\n\t// ---------------------\n\t// FILTERING\n\t// ---------------------\n\n\t#ifdef use_filter_by_normal\n\t\tif(abs((modelViewMatrix * vec4(normal, 0.0)).z) > filterByNormalThreshold) {\n\t\t\t// Move point outside clip space space to discard it.\n\t\t\tgl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\t\t}\n\t#endif\n\n\t// ---------------------\n\t// POINT COLOR\n\t// ---------------------\n\n\t#ifdef color_type_rgb\n\t\tvColor = getRGB();\n\t#elif defined color_type_height\n\t\tvColor = getElevation();\n\t#elif defined color_type_rgb_height\n\t\tvec3 cHeight = getElevation();\n\t\tvColor = (1.0 - transition) * getRGB() + transition * cHeight;\n\t#elif defined color_type_depth\n\t\tfloat linearDepth = -mvPosition.z ;\n\t\tfloat expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;\n\t\tvColor = vec3(linearDepth, expDepth, 0.0);\n\t#elif defined color_type_intensity\n\t\tfloat w = getIntensity();\n\t\tvColor = vec3(w, w, w);\n\t#elif defined color_type_intensity_gradient\n\t\tfloat w = getIntensity();\n\t\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\n\t#elif defined color_type_color\n\t\tvColor = uColor;\n\t#elif defined color_type_lod\n\tfloat w = getLOD() / 10.0;\n\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\n\t#elif defined color_type_point_index\n\t\tvColor = indices.rgb;\n\t#elif defined color_type_classification\n\t  vec4 cl = getClassification();\n\t\tvColor = cl.rgb;\n\t#elif defined color_type_return_number\n\t\tvColor = getReturnNumber();\n\t#elif defined color_type_source\n\t\tvColor = getSourceID();\n\t#elif defined color_type_normal\n\t\tvColor = (modelMatrix * vec4(normal, 0.0)).xyz;\n\t#elif defined color_type_phong\n\t\tvColor = color;\n\t#elif defined color_type_composite\n\t\tvColor = getCompositeColor();\n\t#endif\n\n\t#if !defined color_type_composite && defined color_type_classification\n\t\tif (cl.a == 0.0) {\n\t\t\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\n\t\t\treturn;\n\t\t}\n\t#endif\n\n\t// ---------------------\n\t// CLIPPING\n\t// ---------------------\n\n\t#if defined use_clip_box\n\t\tbool insideAny = false;\n\t\tfor (int i = 0; i < max_clip_boxes; i++) {\n\t\t\tif (i == int(clipBoxCount)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec4 clipPosition = clipBoxes[i] * modelMatrix * vec4(position, 1.0);\n\t\t\tbool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;\n\t\t\tinside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;\n\t\t\tinside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;\n\t\t\tinsideAny = insideAny || inside;\n\t\t}\n\n\t\tif (!insideAny) {\n\t\t\t#if defined clip_outside\n\t\t\t\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\n\t\t\t#elif defined clip_highlight_inside && !defined(color_type_depth)\n\t\t\t\tfloat c = (vColor.r + vColor.g + vColor.b) / 6.0;\n\t\t\t#endif\n\t\t} else {\n\t\t\t#if defined clip_highlight_inside\n\t\t\t\tvColor.r += 0.5;\n\t\t\t#endif\n\t\t}\n\t#endif\n\n\t#if NUM_CLIP_PLANES > 0\n\t\tvec4 plane;\n\t\tvec3 vClipPosition = -(modelMatrix * vec4(position, 1.0)).xyz;\n\t\tfor (int i = 0; i < NUM_CLIP_PLANES; i++) {\n\t\t\tplane = clippingPlanes[i];\n\t\t\tif (dot(vClipPosition, plane.xyz) > plane.w) {\n\t\t\t\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\n\t\t\t};\n\t\t}\n\t#endif\n}\n"},477:t=>{t.exports=function(t,e,i,n){var o=self||window;try{try{var r;try{r=new o.Blob([t])}catch(e){(r=new(o.BlobBuilder||o.WebKitBlobBuilder||o.MozBlobBuilder||o.MSBlobBuilder)).append(t),r=r.getBlob()}var s=o.URL||o.webkitURL,a=s.createObjectURL(r),l=new o[e](a,i);return s.revokeObjectURL(a),l}catch(n){return new o[e]("data:application/javascript,".concat(encodeURIComponent(t)),i)}}catch(t){if(!n)throw Error("Inline worker is not supported");return new o[e](n,i)}}},881:e=>{e.exports=t}},i={};function n(t){var o=i[t];if(void 0!==o)return o.exports;var r=i[t]={exports:{}};return e[t](r,r.exports,n),r.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var i in e)n.o(e,i)&&!n.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{n.r(o),n.d(o,{BlurMaterial:()=>d,ClipMode:()=>t,GRAYSCALE:()=>m,INFERNO:()=>v,PLASMA:()=>x,POINT_ATTRIBUTES:()=>V,POINT_ATTRIBUTE_TYPES:()=>U,PointAttributeName:()=>F,PointAttributes:()=>k,PointCloudMaterial:()=>B,PointCloudOctree:()=>tt,PointCloudOctreeGeometry:()=>q,PointCloudOctreeGeometryNode:()=>K,PointCloudOctreeNode:()=>Q,PointCloudOctreePicker:()=>Z,PointCloudTree:()=>J,PointColorType:()=>a,PointOpacityType:()=>s,PointShape:()=>i,PointSizeType:()=>e,Potree:()=>xt,QueueItem:()=>vt,RAINBOW:()=>y,SPECTRAL:()=>b,TreeType:()=>r,VIRIDIS:()=>_,Version:()=>rt,YELLOW_GREEN:()=>T,generateClassificationTexture:()=>N,generateDataTexture:()=>A,generateGradientTexture:()=>w});var t,e,i,r,s,a,l=n(881);class d extends l.ShaderMaterial{constructor(){super(...arguments),this.vertexShader=n(412),this.fragmentShader=n(913),this.uniforms={screenWidth:{type:"f",value:0},screenHeight:{type:"f",value:0},map:{type:"t",value:null}}}}!function(t){t[t.DISABLED=0]="DISABLED",t[t.CLIP_OUTSIDE=1]="CLIP_OUTSIDE",t[t.HIGHLIGHT_INSIDE=2]="HIGHLIGHT_INSIDE"}(t||(t={})),function(t){t[t.FIXED=0]="FIXED",t[t.ATTENUATED=1]="ATTENUATED",t[t.ADAPTIVE=2]="ADAPTIVE"}(e||(e={})),function(t){t[t.SQUARE=0]="SQUARE",t[t.CIRCLE=1]="CIRCLE",t[t.PARABOLOID=2]="PARABOLOID"}(i||(i={})),function(t){t[t.OCTREE=0]="OCTREE",t[t.KDTREE=1]="KDTREE"}(r||(r={})),function(t){t[t.FIXED=0]="FIXED",t[t.ATTENUATED=1]="ATTENUATED"}(s||(s={})),function(t){t[t.RGB=0]="RGB",t[t.COLOR=1]="COLOR",t[t.DEPTH=2]="DEPTH",t[t.HEIGHT=3]="HEIGHT",t[t.ELEVATION=3]="ELEVATION",t[t.INTENSITY=4]="INTENSITY",t[t.INTENSITY_GRADIENT=5]="INTENSITY_GRADIENT",t[t.LOD=6]="LOD",t[t.LEVEL_OF_DETAIL=6]="LEVEL_OF_DETAIL",t[t.POINT_INDEX=7]="POINT_INDEX",t[t.CLASSIFICATION=8]="CLASSIFICATION",t[t.RETURN_NUMBER=9]="RETURN_NUMBER",t[t.SOURCE=10]="SOURCE",t[t.NORMAL=11]="NORMAL",t[t.PHONG=12]="PHONG",t[t.RGB_HEIGHT=13]="RGB_HEIGHT",t[t.COMPOSITE=50]="COMPOSITE"}(a||(a={}));const c="PerspectiveCamera",u=new l.Color(0,0,0),h=new l.Vector4(1,0,0,1);function p(t){return parseInt(t.charAt(t.length-1),10)}function f(t,e){const i=t.name,n=e.name;return i.length!==n.length?i.length-n.length:i<n?-1:i>n?1:0}const g={0:new l.Vector4(.5,.5,.5,1),1:new l.Vector4(.5,.5,.5,1),2:new l.Vector4(.63,.32,.18,1),3:new l.Vector4(0,1,0,1),4:new l.Vector4(0,.8,0,1),5:new l.Vector4(0,.6,0,1),6:new l.Vector4(1,.66,0,1),7:new l.Vector4(1,0,1,1),8:new l.Vector4(1,0,0,1),9:new l.Vector4(0,0,1,1),12:new l.Vector4(1,1,0,1),DEFAULT:new l.Vector4(.3,.6,.6,.5)},m=[[0,new l.Color(0,0,0)],[1,new l.Color(1,1,1)]],v=[[0,new l.Color(.077,.042,.206)],[.1,new l.Color(.225,.036,.388)],[.2,new l.Color(.373,.074,.432)],[.3,new l.Color(.522,.128,.42)],[.4,new l.Color(.665,.182,.37)],[.5,new l.Color(.797,.255,.287)],[.6,new l.Color(.902,.364,.184)],[.7,new l.Color(.969,.516,.063)],[.8,new l.Color(.988,.683,.072)],[.9,new l.Color(.961,.859,.298)],[1,new l.Color(.988,.998,.645)]],x=[[0,new l.Color(.241,.015,.61)],[.1,new l.Color(.387,.001,.654)],[.2,new l.Color(.524,.025,.653)],[.3,new l.Color(.651,.125,.596)],[.4,new l.Color(.752,.227,.513)],[.5,new l.Color(.837,.329,.431)],[.6,new l.Color(.907,.435,.353)],[.7,new l.Color(.963,.554,.272)],[.8,new l.Color(.992,.681,.195)],[.9,new l.Color(.987,.822,.144)],[1,new l.Color(.94,.975,.131)]],y=[[0,new l.Color(.278,0,.714)],[1/6,new l.Color(0,0,1)],[2/6,new l.Color(0,1,1)],[.5,new l.Color(0,1,0)],[4/6,new l.Color(1,1,0)],[5/6,new l.Color(1,.64,0)],[1,new l.Color(1,0,0)]],b=[[0,new l.Color(.3686,.3098,.6353)],[.1,new l.Color(.1961,.5333,.7412)],[.2,new l.Color(.4,.7608,.6471)],[.3,new l.Color(.6706,.8667,.6431)],[.4,new l.Color(.902,.9608,.5961)],[.5,new l.Color(1,1,.749)],[.6,new l.Color(.9961,.8784,.5451)],[.7,new l.Color(.9922,.6824,.3804)],[.8,new l.Color(.9569,.4275,.2627)],[.9,new l.Color(.8353,.2431,.3098)],[1,new l.Color(.6196,.0039,.2588)]],_=[[0,new l.Color(.267,.005,.329)],[.1,new l.Color(.283,.141,.458)],[.2,new l.Color(.254,.265,.53)],[.3,new l.Color(.207,.372,.553)],[.4,new l.Color(.164,.471,.558)],[.5,new l.Color(.128,.567,.551)],[.6,new l.Color(.135,.659,.518)],[.7,new l.Color(.267,.749,.441)],[.8,new l.Color(.478,.821,.318)],[.9,new l.Color(.741,.873,.15)],[1,new l.Color(.993,.906,.144)]],T=[[0,new l.Color(.1647,.2824,.3451)],[.1,new l.Color(.1338,.3555,.4227)],[.2,new l.Color(.061,.4319,.4864)],[.3,new l.Color(0,.5099,.5319)],[.4,new l.Color(0,.5881,.5569)],[.5,new l.Color(.137,.665,.5614)],[.6,new l.Color(.2906,.7395,.5477)],[.7,new l.Color(.4453,.8099,.5201)],[.8,new l.Color(.6102,.8748,.485)],[.9,new l.Color(.7883,.9323,.4514)],[1,new l.Color(.9804,.9804,.4314)]];function A(t,e,i){const n=t*e,o=new Uint8Array(4*n),r=Math.floor(255*i.r),s=Math.floor(255*i.g),a=Math.floor(255*i.b);for(let t=0;t<n;t++)o[3*t]=r,o[3*t+1]=s,o[3*t+2]=a;const d=new l.DataTexture(o,t,e,l.RGBAFormat);return d.needsUpdate=!0,d.magFilter=l.NearestFilter,d}function w(t){const e=64,i=document.createElement("canvas");i.width=e,i.height=e;const n=i.getContext("2d");n.rect(0,0,e,e);const o=n.createLinearGradient(0,0,e,e);for(let e=0;e<t.length;e++){const i=t[e];o.addColorStop(i[0],`#${i[1].getHexString()}`)}n.fillStyle=o,n.fill();const r=new l.CanvasTexture(i);return r.needsUpdate=!0,r.minFilter=l.LinearFilter,r}function N(t){const e=new Uint8Array(262144);for(let i=0;i<256;i++)for(let n=0;n<256;n++){const o=i+256*n;let r;r=t[i]?t[i]:t[i%32]?t[i%32]:t.DEFAULT,e[4*o+0]=255*r.x,e[4*o+1]=255*r.y,e[4*o+2]=255*r.z,e[4*o+3]=255*r.w}const i=new l.DataTexture(e,256,256,l.RGBAFormat);return i.magFilter=l.NearestFilter,i.needsUpdate=!0,i}var S=function(t,e,i,n){var o,r=arguments.length,s=r<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,i,n);else for(var a=t.length-1;a>=0;a--)(o=t[a])&&(s=(r<3?o(s):r>3?o(e,i,s):o(e,i))||s);return r>3&&s&&Object.defineProperty(e,i,s),s};const P={[r.OCTREE]:"tree_type_octree",[r.KDTREE]:"tree_type_kdtree"},C={[e.FIXED]:"fixed_point_size",[e.ATTENUATED]:"attenuated_point_size",[e.ADAPTIVE]:"adaptive_point_size"},I={[s.ATTENUATED]:"attenuated_opacity",[s.FIXED]:"fixed_opacity"},O={[i.SQUARE]:"square_point_shape",[i.CIRCLE]:"circle_point_shape",[i.PARABOLOID]:"paraboloid_point_shape"},M={[a.RGB]:"color_type_rgb",[a.COLOR]:"color_type_color",[a.DEPTH]:"color_type_depth",[a.HEIGHT]:"color_type_height",[a.INTENSITY]:"color_type_intensity",[a.INTENSITY_GRADIENT]:"color_type_intensity_gradient",[a.LOD]:"color_type_lod",[a.POINT_INDEX]:"color_type_point_index",[a.CLASSIFICATION]:"color_type_classification",[a.RETURN_NUMBER]:"color_type_return_number",[a.SOURCE]:"color_type_source",[a.NORMAL]:"color_type_normal",[a.PHONG]:"color_type_phong",[a.RGB_HEIGHT]:"color_type_rgb_height",[a.COMPOSITE]:"color_type_composite"},E={[t.DISABLED]:"clip_disabled",[t.CLIP_OUTSIDE]:"clip_outside",[t.HIGHLIGHT_INSIDE]:"clip_highlight_inside"};class B extends l.RawShaderMaterial{constructor(n={}){super(),this.lights=!1,this.fog=!1,this.numClipBoxes=0,this.clipBoxes=[],this.visibleNodeTextureOffsets=new Map,this._gradient=b,this.gradientTexture=w(this._gradient),this._classification=g,this.classificationTexture=N(this._classification),this.defines={NUM_CLIP_PLANES:0},this.uniforms={bbSize:L("fv",[0,0,0]),blendDepthSupplement:L("f",0),blendHardness:L("f",2),classificationLUT:L("t",this.classificationTexture||new l.Texture),clipBoxCount:L("f",0),clipBoxes:L("Matrix4fv",[]),clipping:L("b",!0),numClippingPlanes:L("f",0),clippingPlanes:L("fv",[]),depthMap:L("t",null),diffuse:L("fv",[1,1,1]),fov:L("f",1),gradient:L("t",this.gradientTexture||new l.Texture),heightMax:L("f",1),heightMin:L("f",0),intensityBrightness:L("f",0),intensityContrast:L("f",0),intensityGamma:L("f",1),intensityRange:L("fv",[0,65e3]),isLeafNode:L("b",0),level:L("f",0),maxSize:L("f",50),minSize:L("f",2),octreeSize:L("f",0),opacity:L("f",1),pcIndex:L("f",0),rgbBrightness:L("f",0),rgbContrast:L("f",0),rgbGamma:L("f",1),screenHeight:L("f",1),screenWidth:L("f",1),size:L("f",1),spacing:L("f",1),toModel:L("Matrix4f",[]),transition:L("f",.5),uColor:L("c",new l.Color(16777215)),visibleNodes:L("t",this.visibleNodesTexture||new l.Texture),vnStart:L("f",0),wClassification:L("f",0),wElevation:L("f",0),wIntensity:L("f",0),wReturnNumber:L("f",0),wRGB:L("f",1),wSourceID:L("f",0),opacityAttenuation:L("f",1),filterByNormalThreshold:L("f",0),highlightedPointCoordinate:L("fv",new l.Vector3),highlightedPointColor:L("fv",h.clone()),enablePointHighlighting:L("b",!0),highlightedPointScale:L("f",2)},this.useClipBox=!1,this.weighted=!1,this.pointColorType=a.RGB,this.pointSizeType=e.ADAPTIVE,this.clipMode=t.DISABLED,this.useEDL=!1,this.shape=i.SQUARE,this.treeType=r.OCTREE,this.pointOpacityType=s.FIXED,this.useFilterByNormal=!1,this.highlightPoint=!1,this.attributes={position:{type:"fv",value:[]},color:{type:"fv",value:[]},normal:{type:"fv",value:[]},intensity:{type:"f",value:[]},classification:{type:"f",value:[]},returnNumber:{type:"f",value:[]},numberOfReturns:{type:"f",value:[]},pointSourceID:{type:"f",value:[]},indices:{type:"fv",value:[]}},this.setValues({defines:this.defines});const o=this.visibleNodesTexture=A(2048,1,new l.Color(16777215));o.minFilter=l.NearestFilter,o.magFilter=l.NearestFilter,this.setUniform("visibleNodes",o),this.treeType=D(n.treeType,r.OCTREE),this.size=D(n.size,1),this.minSize=D(n.minSize,2),this.maxSize=D(n.maxSize,50),this.classification=g,this.defaultAttributeValues.normal=[0,0,0],this.defaultAttributeValues.classification=[0,0,0],this.defaultAttributeValues.indices=[0,0,0,0],this.vertexColors=!0,this.updateShaderSource()}dispose(){super.dispose(),this.gradientTexture&&(this.gradientTexture.dispose(),this.gradientTexture=void 0),this.visibleNodesTexture&&(this.visibleNodesTexture.dispose(),this.visibleNodesTexture=void 0),this.clearVisibleNodeTextureOffsets(),this.classificationTexture&&(this.classificationTexture.dispose(),this.classificationTexture=void 0),this.depthMap&&(this.depthMap.dispose(),this.depthMap=void 0)}clearVisibleNodeTextureOffsets(){this.visibleNodeTextureOffsets.clear()}updateShaderSource(){this.vertexShader=this.applyDefines(n(59).Z),this.fragmentShader=this.applyDefines(n(53).Z),1===this.opacity?(this.blending=l.NoBlending,this.transparent=!1,this.depthTest=!0,this.depthWrite=!0,this.depthFunc=l.LessEqualDepth):this.opacity<1&&!this.useEDL&&(this.blending=l.AdditiveBlending,this.transparent=!0,this.depthTest=!1,this.depthWrite=!0),this.weighted&&(this.blending=l.AdditiveBlending,this.transparent=!0,this.depthTest=!0,this.depthWrite=!1,this.depthFunc=l.LessEqualDepth),this.needsUpdate=!0}applyDefines(t){const e=[];function i(t){t&&e.push(`#define ${t}`)}return i(P[this.treeType]),i(C[this.pointSizeType]),i(O[this.shape]),i(M[this.pointColorType]),i(E[this.clipMode]),i(I[this.pointOpacityType]),1===this.rgbGamma&&0===this.rgbBrightness&&0===this.rgbContrast||i("use_rgb_gamma_contrast_brightness"),this.useFilterByNormal&&i("use_filter_by_normal"),this.useEDL&&i("use_edl"),this.weighted&&i("weighted_splats"),this.numClipBoxes>0&&i("use_clip_box"),this.highlightPoint&&i("highlight_point"),i("MAX_POINT_LIGHTS 0"),i("MAX_DIR_LIGHTS 0"),e.push(t),e.join("\n")}setClipBoxes(t){if(!t)return;this.clipBoxes=t;const e=this.numClipBoxes!==t.length&&(0===t.length||0===this.numClipBoxes);this.numClipBoxes=t.length,this.setUniform("clipBoxCount",this.numClipBoxes),e&&this.updateShaderSource();const i=16*this.numClipBoxes,n=new Float32Array(i);for(let e=0;e<this.numClipBoxes;e++)n.set(t[e].inverse.elements,16*e);for(let t=0;t<i;t++)isNaN(n[t])&&(n[t]=1/0);this.setUniform("clipBoxes",n)}get gradient(){return this._gradient}set gradient(t){this._gradient!==t&&(this._gradient=t,this.gradientTexture=w(this._gradient),this.setUniform("gradient",this.gradientTexture))}get classification(){return this._classification}set classification(t){const e={};for(const i of Object.keys(t))e[i]=t[i].clone();let i=!1;if(void 0===this._classification)i=!1;else{i=Object.keys(e).length===Object.keys(this._classification).length;for(const t of Object.keys(e))i=i&&void 0!==this._classification[t],i=i&&e[t].equals(this._classification[t])}i||(this._classification=e,this.recomputeClassification())}recomputeClassification(){this.classificationTexture=N(this._classification),this.setUniform("classificationLUT",this.classificationTexture)}get elevationRange(){return[this.heightMin,this.heightMax]}set elevationRange(t){this.heightMin=t[0],this.heightMax=t[1]}getUniform(t){return void 0===this.uniforms?void 0:this.uniforms[t].value}setUniform(t,e){if(void 0===this.uniforms)return;const i=this.uniforms[t];"c"===i.type?i.value.copy(e):e!==i.value&&(i.value=e)}updateMaterial(t,i,n,o){const r=o.getPixelRatio();n.type===c?this.fov=n.fov*(Math.PI/180):this.fov=Math.PI/2;const s=o.getRenderTarget();null!==s&&s instanceof l.WebGLRenderTarget?(this.screenWidth=s.width,this.screenHeight=s.height):(this.screenWidth=o.domElement.clientWidth*r,this.screenHeight=o.domElement.clientHeight*r);const d=Math.max(t.scale.x,t.scale.y,t.scale.z);this.spacing=t.pcoGeometry.spacing*d,this.octreeSize=t.pcoGeometry.boundingBox.getSize(B.helperVec3).x,this.pointSizeType!==e.ADAPTIVE&&this.pointColorType!==a.LOD||this.updateVisibilityTextureData(i)}updateVisibilityTextureData(t){t.sort(f);const e=new Uint8Array(4*t.length),i=new Array(t.length).fill(1/0);this.visibleNodeTextureOffsets.clear();for(let n=0;n<t.length;n++){const o=t[n];if(this.visibleNodeTextureOffsets.set(o.name,n),n>0){const t=o.name.slice(0,-1),r=this.visibleNodeTextureOffsets.get(t),s=n-r;i[r]=Math.min(i[r],s);const a=4*r;e[a]=e[a]|1<<o.index,e[a+1]=i[r]>>8,e[a+2]=i[r]%256}e[4*n+3]=o.name.length}const n=this.visibleNodesTexture;n&&(n.image.data.set(e),n.needsUpdate=!0)}static makeOnBeforeRender(t,e,i){return(n,o,r,s,a)=>{const l=a,d=l.uniforms;if(a.clippingPlanes&&a.clippingPlanes.length>0){const t=a.clippingPlanes,e=new Array(4*a.clippingPlanes.length);for(let i=0;i<t.length;i++)e[4*i+0]=t[i].normal.x,e[4*i+1]=t[i].normal.y,e[4*i+2]=t[i].normal.z,e[4*i+3]=t[i].constant;d.clippingPlanes.value=e}l.defines.NUM_CLIP_PLANES=a.clippingPlanes.length,d.level.value=e.level,d.isLeafNode.value=e.isLeafNode;const c=l.visibleNodeTextureOffsets.get(e.name);void 0!==c&&(d.vnStart.value=c),d.pcIndex.value=void 0!==i?i:t.visibleNodes.indexOf(e),a.uniformsNeedUpdate=!0}}}function L(t,e){return{type:t,value:e}}function D(t,e){return void 0===t?e:t}function R(t,e=!1){return(i,n)=>{Object.defineProperty(i,n,{get(){return this.getUniform(t)},set(i){i!==this.getUniform(t)&&(this.setUniform(t,i),e&&this.updateShaderSource())}})}}function z(){return(t,e)=>{const i=`_${e.toString()}`;Object.defineProperty(t,e,{get(){return this[i]},set(t){t!==this[i]&&(this[i]=t,this.updateShaderSource())}})}}var F;B.helperVec3=new l.Vector3,S([R("bbSize")],B.prototype,"bbSize",void 0),S([R("depthMap")],B.prototype,"depthMap",void 0),S([R("fov")],B.prototype,"fov",void 0),S([R("heightMax")],B.prototype,"heightMax",void 0),S([R("heightMin")],B.prototype,"heightMin",void 0),S([R("intensityBrightness")],B.prototype,"intensityBrightness",void 0),S([R("intensityContrast")],B.prototype,"intensityContrast",void 0),S([R("intensityGamma")],B.prototype,"intensityGamma",void 0),S([R("intensityRange")],B.prototype,"intensityRange",void 0),S([R("maxSize")],B.prototype,"maxSize",void 0),S([R("minSize")],B.prototype,"minSize",void 0),S([R("octreeSize")],B.prototype,"octreeSize",void 0),S([R("opacity",!0)],B.prototype,"opacity",void 0),S([R("rgbBrightness",!0)],B.prototype,"rgbBrightness",void 0),S([R("rgbContrast",!0)],B.prototype,"rgbContrast",void 0),S([R("rgbGamma",!0)],B.prototype,"rgbGamma",void 0),S([R("screenHeight")],B.prototype,"screenHeight",void 0),S([R("screenWidth")],B.prototype,"screenWidth",void 0),S([R("size")],B.prototype,"size",void 0),S([R("spacing")],B.prototype,"spacing",void 0),S([R("transition")],B.prototype,"transition",void 0),S([R("uColor")],B.prototype,"color",void 0),S([R("wClassification")],B.prototype,"weightClassification",void 0),S([R("wElevation")],B.prototype,"weightElevation",void 0),S([R("wIntensity")],B.prototype,"weightIntensity",void 0),S([R("wReturnNumber")],B.prototype,"weightReturnNumber",void 0),S([R("wRGB")],B.prototype,"weightRGB",void 0),S([R("wSourceID")],B.prototype,"weightSourceID",void 0),S([R("opacityAttenuation")],B.prototype,"opacityAttenuation",void 0),S([R("filterByNormalThreshold")],B.prototype,"filterByNormalThreshold",void 0),S([R("highlightedPointCoordinate")],B.prototype,"highlightedPointCoordinate",void 0),S([R("highlightedPointColor")],B.prototype,"highlightedPointColor",void 0),S([R("enablePointHighlighting")],B.prototype,"enablePointHighlighting",void 0),S([R("highlightedPointScale")],B.prototype,"highlightedPointScale",void 0),S([z()],B.prototype,"useClipBox",void 0),S([z()],B.prototype,"weighted",void 0),S([z()],B.prototype,"pointColorType",void 0),S([z()],B.prototype,"pointSizeType",void 0),S([z()],B.prototype,"clipMode",void 0),S([z()],B.prototype,"useEDL",void 0),S([z()],B.prototype,"shape",void 0),S([z()],B.prototype,"treeType",void 0),S([z()],B.prototype,"pointOpacityType",void 0),S([z()],B.prototype,"useFilterByNormal",void 0),S([z()],B.prototype,"highlightPoint",void 0),function(t){t[t.POSITION_CARTESIAN=0]="POSITION_CARTESIAN",t[t.COLOR_PACKED=1]="COLOR_PACKED",t[t.COLOR_FLOATS_1=2]="COLOR_FLOATS_1",t[t.COLOR_FLOATS_255=3]="COLOR_FLOATS_255",t[t.NORMAL_FLOATS=4]="NORMAL_FLOATS",t[t.FILLER=5]="FILLER",t[t.INTENSITY=6]="INTENSITY",t[t.CLASSIFICATION=7]="CLASSIFICATION",t[t.NORMAL_SPHEREMAPPED=8]="NORMAL_SPHEREMAPPED",t[t.NORMAL_OCT16=9]="NORMAL_OCT16",t[t.NORMAL=10]="NORMAL"}(F||(F={}));const U={DATA_TYPE_DOUBLE:{ordinal:0,size:8},DATA_TYPE_FLOAT:{ordinal:1,size:4},DATA_TYPE_INT8:{ordinal:2,size:1},DATA_TYPE_UINT8:{ordinal:3,size:1},DATA_TYPE_INT16:{ordinal:4,size:2},DATA_TYPE_UINT16:{ordinal:5,size:2},DATA_TYPE_INT32:{ordinal:6,size:4},DATA_TYPE_UINT32:{ordinal:7,size:4},DATA_TYPE_INT64:{ordinal:8,size:8},DATA_TYPE_UINT64:{ordinal:9,size:8}};function G(t,e,i){return{name:t,type:e,numElements:i,byteSize:i*e.size}}const H=G(F.COLOR_PACKED,U.DATA_TYPE_INT8,4),V={POSITION_CARTESIAN:G(F.POSITION_CARTESIAN,U.DATA_TYPE_FLOAT,3),RGBA_PACKED:H,COLOR_PACKED:H,RGB_PACKED:G(F.COLOR_PACKED,U.DATA_TYPE_INT8,3),NORMAL_FLOATS:G(F.NORMAL_FLOATS,U.DATA_TYPE_FLOAT,3),FILLER_1B:G(F.FILLER,U.DATA_TYPE_UINT8,1),INTENSITY:G(F.INTENSITY,U.DATA_TYPE_UINT16,1),CLASSIFICATION:G(F.CLASSIFICATION,U.DATA_TYPE_UINT8,1),NORMAL_SPHEREMAPPED:G(F.NORMAL_SPHEREMAPPED,U.DATA_TYPE_UINT8,2),NORMAL_OCT16:G(F.NORMAL_OCT16,U.DATA_TYPE_UINT8,2),NORMAL:G(F.NORMAL,U.DATA_TYPE_FLOAT,3)};class k{constructor(t=[]){this.attributes=[],this.byteSize=0,this.size=0;for(let e=0;e<t.length;e++){const i=t[e],n=V[i];this.attributes.push(n),this.byteSize+=n.byteSize,this.size++}}add(t){this.attributes.push(t),this.byteSize+=t.byteSize,this.size++}hasColors(){return void 0!==this.attributes.find(W)}hasNormals(){return void 0!==this.attributes.find(j)}}function W({name:t}){return t===F.COLOR_PACKED}function j({name:t}){return t===F.NORMAL_SPHEREMAPPED||t===F.NORMAL_FLOATS||t===F.NORMAL||t===F.NORMAL_OCT16}function Y(t,e){return(new l.Box3).setFromPoints([new l.Vector3(t.min.x,t.min.y,t.min.z).applyMatrix4(e),new l.Vector3(t.min.x,t.min.y,t.min.z).applyMatrix4(e),new l.Vector3(t.max.x,t.min.y,t.min.z).applyMatrix4(e),new l.Vector3(t.min.x,t.max.y,t.min.z).applyMatrix4(e),new l.Vector3(t.min.x,t.min.y,t.max.z).applyMatrix4(e),new l.Vector3(t.min.x,t.max.y,t.max.z).applyMatrix4(e),new l.Vector3(t.max.x,t.max.y,t.min.z).applyMatrix4(e),new l.Vector3(t.max.x,t.min.y,t.max.z).applyMatrix4(e),new l.Vector3(t.max.x,t.max.y,t.max.z).applyMatrix4(e)])}function X(t,e){const i=t.min.clone(),n=t.max.clone(),o=(new l.Vector3).subVectors(n,i);return(1&e)>0?i.z+=o.z/2:n.z-=o.z/2,(2&e)>0?i.y+=o.y/2:n.y-=o.y/2,(4&e)>0?i.x+=o.x/2:n.x-=o.x/2,new l.Box3(i,n)}class K extends l.EventDispatcher{constructor(t,e,i){super(),this.id=K.idCount++,this.level=0,this.spacing=0,this.hasChildren=!1,this.children=[null,null,null,null,null,null,null,null],this.mean=new l.Vector3,this.numPoints=0,this.loaded=!1,this.loading=!1,this.failed=!1,this.parent=null,this.oneTimeDisposeHandlers=[],this.isLeafNode=!0,this.isTreeNode=!1,this.isGeometryNode=!0,this.name=t,this.index=p(t),this.pcoGeometry=e,this.boundingBox=i,this.tightBoundingBox=i.clone(),this.boundingSphere=i.getBoundingSphere(new l.Sphere)}dispose(){this.geometry&&this.parent&&(this.geometry.dispose(),this.geometry=void 0,this.loaded=!1,this.oneTimeDisposeHandlers.forEach((t=>t())),this.oneTimeDisposeHandlers=[])}getUrl(){const t=this.pcoGeometry,e=t.loader.version,i=[t.octreeDir];return t.loader&&e.equalOrHigher("1.5")?(i.push(this.getHierarchyBaseUrl()),i.push(this.name)):(e.equalOrHigher("1.4")||e.upTo("1.3"))&&i.push(this.name),i.join("/")}getHierarchyUrl(){return`${this.pcoGeometry.octreeDir}/${this.getHierarchyBaseUrl()}/${this.name}.hrc`}addChild(t){this.children[t.index]=t,this.isLeafNode=!1,t.parent=this}traverse(t,e=!0){const i=e?[this]:[];let n;for(;void 0!==(n=i.pop());){t(n);for(const t of n.children)null!==t&&i.push(t)}}load(){if(!this.canLoad())return Promise.resolve();let t;return this.loading=!0,this.pcoGeometry.numNodesLoading++,this.pcoGeometry.needsUpdate=!0,t=this.pcoGeometry.loader.version.equalOrHigher("1.5")&&this.level%this.pcoGeometry.hierarchyStepSize==0&&this.hasChildren?this.loadHierachyThenPoints():this.loadPoints(),t.catch((t=>{throw this.loading=!1,this.failed=!0,this.pcoGeometry.numNodesLoading--,t}))}canLoad(){return!this.loading&&!this.loaded&&!this.pcoGeometry.disposed&&!this.pcoGeometry.loader.disposed&&this.pcoGeometry.numNodesLoading<this.pcoGeometry.maxNumNodesLoading}loadPoints(){return this.pcoGeometry.needsUpdate=!0,this.pcoGeometry.loader.load(this)}loadHierachyThenPoints(){return this.level%this.pcoGeometry.hierarchyStepSize!=0?Promise.resolve():Promise.resolve(this.pcoGeometry.loader.getUrl(this.getHierarchyUrl())).then((t=>this.pcoGeometry.xhrRequest(t,{mode:"cors"}))).then((t=>t.arrayBuffer())).then((t=>this.loadHierarchy(this,t)))}getHierarchyBaseUrl(){const t=this.pcoGeometry.hierarchyStepSize,e=this.name.substr(1),i=Math.floor(e.length/t);let n="r/";for(let o=0;o<i;o++)n+=`${e.substr(o*t,t)}/`;return n.slice(0,-1)}loadHierarchy(t,e){const i=new DataView(e),n=this.getNodeData(t.name,0,i);t.numPoints=n.numPoints;const o=[n],r=[];let s=5;for(;o.length>0;){const t=o.shift();let n=1;for(let a=0;a<8&&s+1<e.byteLength;a++){if(0!=(t.children&n)){const e=this.getNodeData(t.name+a,s,i);r.push(e),o.push(e),s+=5}n*=2}}t.pcoGeometry.needsUpdate=!0;const a=new Map;a.set(t.name,t),r.forEach((e=>this.addNode(e,t.pcoGeometry,a))),t.loadPoints()}getNodeData(t,e,i){return{children:i.getUint8(e),numPoints:i.getUint32(e+1,!0),name:t}}addNode({name:t,numPoints:e,children:i},n,o){const r=p(t),s=t.substring(0,t.length-1),a=o.get(s),l=t.length-1,d=X(a.boundingBox,r),c=new K(t,n,d);c.level=l,c.numPoints=e,c.hasChildren=i>0,c.spacing=n.spacing/Math.pow(2,l),a.addChild(c),o.set(t,c)}}K.idCount=0;class q{constructor(t,e,i,n,o){this.loader=t,this.boundingBox=e,this.tightBoundingBox=i,this.offset=n,this.xhrRequest=o,this.disposed=!1,this.needsUpdate=!0,this.octreeDir="",this.hierarchyStepSize=-1,this.nodes={},this.numNodesLoading=0,this.maxNumNodesLoading=3,this.spacing=0,this.pointAttributes=new k([]),this.projection=null,this.url=null}dispose(){this.loader.dispose(),this.root.traverse((t=>t.dispose())),this.disposed=!0}addNodeLoadedCallback(t){this.loader.callbacks.push(t)}clearNodeLoadedCallbacks(){this.loader.callbacks=[]}}class Q extends l.EventDispatcher{constructor(t,e){super(),this.pcIndex=void 0,this.boundingBoxNode=null,this.loaded=!0,this.isTreeNode=!0,this.isGeometryNode=!1,this.geometryNode=t,this.sceneNode=e,this.children=t.children.slice()}dispose(){this.geometryNode.dispose()}disposeSceneNode(){const t=this.sceneNode;if(t.geometry instanceof l.BufferGeometry){const e=t.geometry.attributes;for(const t in e)"position"===t&&delete e[t].array,delete e[t];t.geometry.dispose(),t.geometry=void 0}}traverse(t,e){this.geometryNode.traverse(t,e)}get id(){return this.geometryNode.id}get name(){return this.geometryNode.name}get level(){return this.geometryNode.level}get isLeafNode(){return this.geometryNode.isLeafNode}get numPoints(){return this.geometryNode.numPoints}get index(){return this.geometryNode.index}get boundingSphere(){return this.geometryNode.boundingSphere}get boundingBox(){return this.geometryNode.boundingBox}get spacing(){return this.geometryNode.spacing}}function $(t,e,i){return Math.min(Math.max(e,t),i)}class Z{dispose(){this.pickState&&(this.pickState.material.dispose(),this.pickState.renderTarget.dispose())}pick(t,e,i,n,o={}){if(0===n.length)return null;const r=this.pickState?this.pickState:this.pickState=Z.getPickState(),s=r.material,a=t.getPixelRatio(),l=Math.ceil(t.domElement.clientWidth*a),d=Math.ceil(t.domElement.clientHeight*a);Z.updatePickRenderTarget(this.pickState,l,d);const c=Z.helperVec3;o.pixelPosition?c.copy(o.pixelPosition):(c.addVectors(e.position,i.direction).project(e),c.x=(c.x+1)*l*.5,c.y=(c.y+1)*d*.5);const u=Math.floor((o.pickWindowSize||15)*a),h=(u-1)/2,p=Math.floor($(c.x-h,0,l)),f=Math.floor($(c.y-h,0,d));Z.prepareRender(t,p,f,u,s,r);const g=Z.render(t,e,s,n,i,r,o);s.clearVisibleNodeTextureOffsets();const m=Z.readPixels(t,p,f,u),v=Z.findHit(m,u);return Z.getPickPoint(v,g)}static prepareRender(t,e,i,n,o,r){t.setScissor(e,i,n,n),t.setScissorTest(!0),t.state.buffers.depth.setTest(o.depthTest),t.state.buffers.depth.setMask(o.depthWrite),t.state.setBlending(l.NoBlending),t.setRenderTarget(r.renderTarget),t.getClearColor(this.clearColor);const s=t.getClearAlpha();t.setClearColor(u,0),t.clear(!0,!0,!0),t.setClearColor(this.clearColor,s)}static render(t,e,i,n,o,r,s){const a=[];for(const l of n){const n=Z.nodesOnRay(l,o);n.length&&(Z.updatePickMaterial(i,l.material,s),i.updateMaterial(l,n,e,t),s.onBeforePickRender&&s.onBeforePickRender(i,r.renderTarget),r.scene.children=Z.createTempNodes(l,n,i,a.length),t.render(r.scene,e),n.forEach((t=>a.push({node:t,octree:l}))))}return a}static nodesOnRay(t,e){const i=[],n=e.clone();for(const e of t.visibleNodes){const o=Z.helperSphere.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);n.intersectsSphere(o)&&i.push(e)}return i}static readPixels(t,e,i,n){const o=new Uint8Array(4*n*n);return t.readRenderTargetPixels(t.getRenderTarget(),e,i,n,n,o),t.setScissorTest(!1),t.setRenderTarget(null),o}static createTempNodes(t,e,i,n){const o=[];for(let r=0;r<e.length;r++){const s=e[r],a=s.sceneNode,d=new l.Points(a.geometry,i);d.matrix=a.matrix,d.matrixWorld=a.matrixWorld,d.matrixAutoUpdate=!1,d.frustumCulled=!1;const c=n+r+1;c>255&&console.error("More than 255 nodes for pick are not supported."),d.onBeforeRender=B.makeOnBeforeRender(t,s,c),o.push(d)}return o}static updatePickMaterial(e,i,n){e.pointSizeType=i.pointSizeType,e.shape=i.shape,e.size=i.size,e.minSize=i.minSize,e.maxSize=i.maxSize,e.classification=i.classification,e.useFilterByNormal=i.useFilterByNormal,e.filterByNormalThreshold=i.filterByNormalThreshold,n.pickOutsideClipRegion?e.clipMode=t.DISABLED:(e.clipMode=i.clipMode,e.setClipBoxes(i.clipMode===t.CLIP_OUTSIDE?i.clipBoxes:[]))}static updatePickRenderTarget(t,e,i){t.renderTarget.width===e&&t.renderTarget.height===i||(t.renderTarget.dispose(),t.renderTarget=Z.makePickRenderTarget(),t.renderTarget.setSize(e,i))}static makePickRenderTarget(){return new l.WebGLRenderTarget(1,1,{minFilter:l.LinearFilter,magFilter:l.NearestFilter,format:l.RGBAFormat})}static findHit(t,e){const i=new Uint32Array(t.buffer);let n=Number.MAX_VALUE,o=null;for(let r=0;r<e;r++)for(let s=0;s<e;s++){const a=r+s*e,l=Math.pow(r-(e-1)/2,2)+Math.pow(s-(e-1)/2,2),d=t[4*a+3];t[4*a+3]=0;const c=i[a];d>0&&l<n&&(o={pIndex:c,pcIndex:d-1},n=l)}return o}static getPickPoint(t,e){if(!t)return null;const i={},n=e[t.pcIndex]&&e[t.pcIndex].node.sceneNode;if(!n)return null;i.pointCloud=e[t.pcIndex].octree;const o=n.geometry.attributes;for(const e in o){if(!o.hasOwnProperty(e))continue;const r=o[e];if("position"===e)Z.addPositionToPickPoint(i,t,r,n);else if("normal"===e)Z.addNormalToPickPoint(i,t,r,n);else if("indices"===e);else if(1===r.itemSize)i[e]=r.array[t.pIndex];else{const n=[];for(let e=0;e<r.itemSize;e++)n.push(r.array[r.itemSize*t.pIndex+e]);i[e]=n}}return i}static addPositionToPickPoint(t,e,i,n){t.position=(new l.Vector3).fromBufferAttribute(i,e.pIndex).applyMatrix4(n.matrixWorld)}static addNormalToPickPoint(t,e,i,n){const o=(new l.Vector3).fromBufferAttribute(i,e.pIndex),r=new l.Vector4(o.x,o.y,o.z,0).applyMatrix4(n.matrixWorld);o.set(r.x,r.y,r.z),t.normal=o}static getPickState(){const t=new l.Scene;t.autoUpdate=!1;const e=new B;return e.pointColorType=a.POINT_INDEX,{renderTarget:Z.makePickRenderTarget(),material:e,scene:t}}}Z.helperVec3=new l.Vector3,Z.helperSphere=new l.Sphere,Z.clearColor=new l.Color;class J extends l.Object3D{constructor(){super(...arguments),this.root=null}initialized(){return null!==this.root}}class tt extends J{constructor(t,e,i){super(),this.disposed=!1,this.level=0,this.maxLevel=1/0,this.minNodePixelSize=50,this.root=null,this.boundingBoxNodes=[],this.visibleNodes=[],this.visibleGeometry=[],this.numVisiblePoints=0,this.showBoundingBox=!1,this.visibleBounds=new l.Box3,this.name="",this.potree=t,this.root=e.root,this.pcoGeometry=e,this.boundingBox=e.boundingBox,this.boundingSphere=this.boundingBox.getBoundingSphere(new l.Sphere),this.position.copy(e.offset),this.updateMatrix(),this.material=i||new B,this.initMaterial(this.material)}initMaterial(t){this.updateMatrixWorld(!0);const{min:e,max:i}=Y(this.pcoGeometry.tightBoundingBox||this.getBoundingBoxWorld(),this.matrixWorld),n=i.z-e.z;t.heightMin=e.z-.2*n,t.heightMax=i.z+.2*n}dispose(){this.root&&this.root.dispose(),this.pcoGeometry.root.traverse((t=>this.potree.lru.remove(t))),this.pcoGeometry.dispose(),this.material.dispose(),this.visibleNodes=[],this.visibleGeometry=[],this.picker&&(this.picker.dispose(),this.picker=void 0),this.disposed=!0}get pointSizeType(){return this.material.pointSizeType}set pointSizeType(t){this.material.pointSizeType=t}toTreeNode(t,e){const i=new l.Points(t.geometry,this.material),n=new Q(t,i);return i.name=t.name,i.position.copy(t.boundingBox.min),i.frustumCulled=!1,i.onBeforeRender=B.makeOnBeforeRender(this,n),e?(e.sceneNode.add(i),e.children[t.index]=n,t.oneTimeDisposeHandlers.push((()=>{n.disposeSceneNode(),e.sceneNode.remove(n.sceneNode),e.children[t.index]=t}))):(this.root=n,this.add(i)),n}updateVisibleBounds(){const t=this.visibleBounds;t.min.set(1/0,1/0,1/0),t.max.set(-1/0,-1/0,-1/0);for(const e of this.visibleNodes)e.isLeafNode&&(t.expandByPoint(e.boundingBox.min),t.expandByPoint(e.boundingBox.max))}updateBoundingBoxes(){if(!this.showBoundingBox||!this.parent)return;let t=this.parent.getObjectByName("bbroot");t||(t=new l.Object3D,t.name="bbroot",this.parent.add(t));const e=[];for(const t of this.visibleNodes)void 0!==t.boundingBoxNode&&t.isLeafNode&&e.push(t.boundingBoxNode);t.children=e}updateMatrixWorld(t){!0===this.matrixAutoUpdate&&this.updateMatrix(),!0!==this.matrixWorldNeedsUpdate&&!0!==t||(this.parent?this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix):this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0)}hideDescendants(t){const e=[];for(i(t);e.length>0;){const t=e.shift();t.visible=!1,i(t)}function i(t){for(const i of t.children)i.visible&&e.push(i)}}moveToOrigin(){this.position.set(0,0,0),this.position.set(0,0,0).sub(this.getBoundingBoxWorld().getCenter(new l.Vector3))}moveToGroundPlane(){this.position.y+=-this.getBoundingBoxWorld().min.y}getBoundingBoxWorld(){return this.updateMatrixWorld(!0),Y(this.boundingBox,this.matrixWorld)}getVisibleExtent(){return this.visibleBounds.applyMatrix4(this.matrixWorld)}pick(t,e,i,n={}){return this.picker=this.picker||new Z,this.picker.pick(t,e,i,[this],n)}get progress(){return 0===this.visibleGeometry.length?0:this.visibleNodes.length/this.visibleGeometry.length}}const et=document.createElement("canvas").getContext("webgl"),it={SHADER_INTERPOLATION:nt("EXT_frag_depth")&&ot(8),SHADER_SPLATS:nt("EXT_frag_depth")&&nt("OES_texture_float")&&ot(8),SHADER_EDL:nt("OES_texture_float")&&ot(8),precision:function(){if(null===et)return"";const t=et.getShaderPrecisionFormat(et.VERTEX_SHADER,et.HIGH_FLOAT),e=et.getShaderPrecisionFormat(et.VERTEX_SHADER,et.MEDIUM_FLOAT),i=et.getShaderPrecisionFormat(et.FRAGMENT_SHADER,et.HIGH_FLOAT),n=et.getShaderPrecisionFormat(et.FRAGMENT_SHADER,et.MEDIUM_FLOAT),o=t&&i&&t.precision>0&&i.precision>0,r=e&&n&&e.precision>0&&n.precision>0;return o?"highp":r?"mediump":"lowp"}()};function nt(t){return null!==et&&Boolean(et.getExtension(t))}function ot(t){return null!==et&&et.getParameter(et.MAX_VARYING_VECTORS)>=t}class rt{constructor(t){this.versionMinor=0,this.version=t;const e=-1===t.indexOf(".")?t.length:t.indexOf(".");this.versionMajor=parseInt(t.substr(0,e),10),this.versionMinor=parseInt(t.substr(e+1),10),isNaN(this.versionMinor)&&(this.versionMinor=0)}newerThan(t){const e=new rt(t);return this.versionMajor>e.versionMajor||this.versionMajor===e.versionMajor&&this.versionMinor>e.versionMinor}equalOrHigher(t){const e=new rt(t);return this.versionMajor>e.versionMajor||this.versionMajor===e.versionMajor&&this.versionMinor>=e.versionMinor}upTo(t){return!this.newerThan(t)}}var st=n(477),at=n.n(st);function lt(){return at()('(()=>{"use strict";var t,e={14:(t,e,n)=>{var r;n.r(e),n.d(e,{handleMessage:()=>c}),function(t){t[t.POSITION_CARTESIAN=0]="POSITION_CARTESIAN",t[t.COLOR_PACKED=1]="COLOR_PACKED",t[t.COLOR_FLOATS_1=2]="COLOR_FLOATS_1",t[t.COLOR_FLOATS_255=3]="COLOR_FLOATS_255",t[t.NORMAL_FLOATS=4]="NORMAL_FLOATS",t[t.FILLER=5]="FILLER",t[t.INTENSITY=6]="INTENSITY",t[t.CLASSIFICATION=7]="CLASSIFICATION",t[t.NORMAL_SPHEREMAPPED=8]="NORMAL_SPHEREMAPPED",t[t.NORMAL_OCT16=9]="NORMAL_OCT16",t[t.NORMAL=10]="NORMAL"}(r||(r={}));const i={ordinal:1,size:4},s={ordinal:2,size:1},o={ordinal:3,size:1};function a(t,e,n){return{name:t,type:e,numElements:n,byteSize:n*e.size}}const u=a(r.COLOR_PACKED,s,4),f={POSITION_CARTESIAN:a(r.POSITION_CARTESIAN,i,3),RGBA_PACKED:u,COLOR_PACKED:u,RGB_PACKED:a(r.COLOR_PACKED,s,3),NORMAL_FLOATS:a(r.NORMAL_FLOATS,i,3),FILLER_1B:a(r.FILLER,o,1),INTENSITY:a(r.INTENSITY,{ordinal:5,size:2},1),CLASSIFICATION:a(r.CLASSIFICATION,o,1),NORMAL_SPHEREMAPPED:a(r.NORMAL_SPHEREMAPPED,o,2),NORMAL_OCT16:a(r.NORMAL_OCT16,o,2),NORMAL:a(r.NORMAL,i,3)};class A{constructor(t){this.versionMinor=0,this.version=t;const e=-1===t.indexOf(".")?t.length:t.indexOf(".");this.versionMajor=parseInt(t.substr(0,e),10),this.versionMinor=parseInt(t.substr(e+1),10),isNaN(this.versionMinor)&&(this.versionMinor=0)}newerThan(t){const e=new A(t);return this.versionMajor>e.versionMajor||this.versionMajor===e.versionMajor&&this.versionMinor>e.versionMinor}equalOrHigher(t){const e=new A(t);return this.versionMajor>e.versionMajor||this.versionMajor===e.versionMajor&&this.versionMinor>=e.versionMinor}upTo(t){return!this.newerThan(t)}}class O{constructor(t){this.tmp=new ArrayBuffer(4),this.tmpf=new Float32Array(this.tmp),this.tmpu8=new Uint8Array(this.tmp),this.u8=new Uint8Array(t)}getUint32(t){return this.u8[t+3]<<24|this.u8[t+2]<<16|this.u8[t+1]<<8|this.u8[t]}getUint16(t){return this.u8[t+1]<<8|this.u8[t]}getFloat32(t){const e=this.tmpu8,n=this.u8,r=this.tmpf;return e[0]=n[t+0],e[1]=n[t+1],e[2]=n[t+2],e[3]=n[t+3],r[0]}getUint8(t){return this.u8[t]}}const b=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1};function c(t){const e=t.data.buffer,n=t.data.pointAttributes,i={attributeBuffers:{},currentOffset:0,data:new O(e),mean:[0,0,0],nodeOffset:t.data.offset,numPoints:t.data.buffer.byteLength/n.byteSize,pointAttributes:n,scale:t.data.scale,tightBoxMax:[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],tightBoxMin:[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],transferables:[],version:new A(t.data.version)};for(const t of i.pointAttributes.attributes)I(t,i),i.currentOffset+=t.byteSize;const s=new ArrayBuffer(4*i.numPoints),o=new Uint32Array(s);for(let t=0;t<i.numPoints;t++)o[t]=t;i.attributeBuffers[r.CLASSIFICATION]||function(t){const e=new ArrayBuffer(4*t.numPoints),n=new Float32Array(e);for(let e=0;e<t.numPoints;e++)n[e]=0;t.attributeBuffers[r.CLASSIFICATION]={buffer:e,attribute:f.CLASSIFICATION}}(i);const a={buffer:e,mean:i.mean,attributeBuffers:i.attributeBuffers,tightBoundingBox:{min:i.tightBoxMin,max:i.tightBoxMax},indices:s};postMessage(a,i.transferables)}function I(t,e){const n=function(t,e){switch(t.name){case r.POSITION_CARTESIAN:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){let n,i,s;e.version.newerThan("1.3")?(n=e.data.getUint32(e.currentOffset+t*e.pointAttributes.byteSize+0)*e.scale,i=e.data.getUint32(e.currentOffset+t*e.pointAttributes.byteSize+4)*e.scale,s=e.data.getUint32(e.currentOffset+t*e.pointAttributes.byteSize+8)*e.scale):(n=e.data.getFloat32(t*e.pointAttributes.byteSize+0)+e.nodeOffset[0],i=e.data.getFloat32(t*e.pointAttributes.byteSize+4)+e.nodeOffset[1],s=e.data.getFloat32(t*e.pointAttributes.byteSize+8)+e.nodeOffset[2]),r[3*t+0]=n,r[3*t+1]=i,r[3*t+2]=s,e.mean[0]+=n/e.numPoints,e.mean[1]+=i/e.numPoints,e.mean[2]+=s/e.numPoints,e.tightBoxMin[0]=Math.min(e.tightBoxMin[0],n),e.tightBoxMin[1]=Math.min(e.tightBoxMin[1],i),e.tightBoxMin[2]=Math.min(e.tightBoxMin[2],s),e.tightBoxMax[0]=Math.max(e.tightBoxMax[0],n),e.tightBoxMax[1]=Math.max(e.tightBoxMax[1],i),e.tightBoxMax[2]=Math.max(e.tightBoxMax[2],s)}return{buffer:n,attribute:t}}(t,e);case r.COLOR_PACKED:return function(t,e){const n=new ArrayBuffer(3*e.numPoints),r=new Uint8Array(n);for(let t=0;t<e.numPoints;t++)r[3*t+0]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+0),r[3*t+1]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+1),r[3*t+2]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+2);return{buffer:n,attribute:t}}(t,e);case r.INTENSITY:return function(t,e){const n=new ArrayBuffer(4*e.numPoints),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++)r[t]=e.data.getUint16(e.currentOffset+t*e.pointAttributes.byteSize);return{buffer:n,attribute:t}}(t,e);case r.CLASSIFICATION:return function(t,e){const n=new ArrayBuffer(e.numPoints),r=new Uint8Array(n);for(let t=0;t<e.numPoints;t++)r[t]=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize);return{buffer:n,attribute:t}}(t,e);case r.NORMAL_SPHEREMAPPED:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){let n=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+0)/255*2-1,i=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+1)/255*2-1,s=1;const o=n*-n+i*-i+1*s;s=o,n*=Math.sqrt(o),i*=Math.sqrt(o),n*=2,i*=2,s=2*s-1,r[3*t+0]=n,r[3*t+1]=i,r[3*t+2]=s}return{buffer:n,attribute:t}}(t,e);case r.NORMAL_OCT16:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){const n=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+0)/255*2-1,i=e.data.getUint8(e.currentOffset+t*e.pointAttributes.byteSize+1)/255*2-1;let s=1-Math.abs(n)-Math.abs(i),o=0,a=0;s>=0?(o=n,a=i):(o=-(i/b(i)-1)/b(n),a=-(n/b(n)-1)/b(i));const u=Math.sqrt(o*o+a*a+s*s);o/=u,a/=u,s/=u,r[3*t+0]=o,r[3*t+1]=a,r[3*t+2]=s}return{buffer:n,attribute:t}}(t,e);case r.NORMAL:return function(t,e){const n=new ArrayBuffer(4*e.numPoints*3),r=new Float32Array(n);for(let t=0;t<e.numPoints;t++){const n=e.data.getFloat32(e.currentOffset+t*e.pointAttributes.byteSize+0),i=e.data.getFloat32(e.currentOffset+t*e.pointAttributes.byteSize+4),s=e.data.getFloat32(e.currentOffset+t*e.pointAttributes.byteSize+8);r[3*t+0]=n,r[3*t+1]=i,r[3*t+2]=s}return{buffer:n,attribute:t}}(t,e);default:return}}(t,e);void 0!==n&&(e.attributeBuffers[n.attribute.name]=n,e.transferables.push(n.buffer))}}},n={};function r(t){var i=n[t];if(void 0!==i)return i.exports;var s=n[t]={exports:{}};return e[t](s,s.exports,r),s.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},t=r(14),onmessage=t.handleMessage})();',"Worker",void 0,void 0)}class dt{constructor({getUrl:t=(t=>Promise.resolve(t)),version:e,boundingBox:i,scale:n,xhrRequest:o}){this.disposed=!1,this.workers=[],this.version="string"==typeof e?new rt(e):e,this.xhrRequest=o,this.getUrl=t,this.boundingBox=i,this.scale=n,this.callbacks=[]}dispose(){this.workers.forEach((t=>t.terminate())),this.workers=[],this.disposed=!0}load(t){return t.loaded||this.disposed?Promise.resolve():Promise.resolve(this.getUrl(this.getNodeUrl(t))).then((t=>this.xhrRequest(t,{mode:"cors"}))).then((t=>t.arrayBuffer())).then((e=>new Promise((i=>this.parse(t,e,i)))))}getNodeUrl(t){let e=t.getUrl();return this.version.equalOrHigher("1.4")&&(e+=".bin"),e}parse(t,e,i){if(this.disposed)return void i();const n=this.getWorker(),o=t.pcoGeometry.pointAttributes,r=e.byteLength/o.byteSize;this.version.upTo("1.5")&&(t.numPoints=r),n.onmessage=e=>{if(this.disposed)return void i();const o=e.data,s=t.geometry=t.geometry||new l.BufferGeometry;s.boundingBox=t.boundingBox,this.addBufferAttributes(s,o.attributeBuffers),this.addIndices(s,o.indices),this.addNormalAttribute(s,r),t.mean=(new l.Vector3).fromArray(o.mean),t.tightBoundingBox=this.getTightBoundingBox(o.tightBoundingBox),t.loaded=!0,t.loading=!1,t.failed=!1,t.pcoGeometry.numNodesLoading--,t.pcoGeometry.needsUpdate=!0,this.releaseWorker(n),this.callbacks.forEach((e=>e(t))),i()};const s={buffer:e,pointAttributes:o,version:this.version.version,min:t.boundingBox.min.toArray(),offset:t.pcoGeometry.offset.toArray(),scale:this.scale,spacing:t.spacing,hasChildren:t.hasChildren};n.postMessage(s,[s.buffer])}getWorker(){return this.workers.pop()||new lt}releaseWorker(t){this.workers.push(t)}getTightBoundingBox({min:t,max:e}){const i=new l.Box3((new l.Vector3).fromArray(t),(new l.Vector3).fromArray(e));return i.max.sub(i.min),i.min.set(0,0,0),i}addBufferAttributes(t,e){Object.keys(e).forEach((i=>{const n=e[i].buffer;this.isAttribute(i,F.POSITION_CARTESIAN)?t.setAttribute("position",new l.BufferAttribute(new Float32Array(n),3)):this.isAttribute(i,F.COLOR_PACKED)?t.setAttribute("color",new l.BufferAttribute(new Uint8Array(n),3,!0)):this.isAttribute(i,F.INTENSITY)?t.setAttribute("intensity",new l.BufferAttribute(new Float32Array(n),1)):this.isAttribute(i,F.CLASSIFICATION)?t.setAttribute("classification",new l.BufferAttribute(new Uint8Array(n),1)):(this.isAttribute(i,F.NORMAL_SPHEREMAPPED)||this.isAttribute(i,F.NORMAL_OCT16)||this.isAttribute(i,F.NORMAL))&&t.setAttribute("normal",new l.BufferAttribute(new Float32Array(n),3))}))}addIndices(t,e){const i=new l.Uint8BufferAttribute(e,4);i.normalized=!0,t.setAttribute("indices",i)}addNormalAttribute(t,e){if(!t.getAttribute("normal")){const i=new Float32Array(3*e);t.setAttribute("normal",new l.BufferAttribute(new Float32Array(i),3))}}isAttribute(t,e){return parseInt(t,10)===e}}function ct(t){return{index:p(t),parentName:t.substring(0,t.length-1),level:t.length-1}}function ut(t){return null!=t&&t.isGeometryNode}function ht(t){return null!=t&&t.isTreeNode}var pt=n(689);class ft extends l.LineSegments{constructor(t,e=new l.Color(16776960)){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array([t.min.x,t.min.y,t.min.z,t.max.x,t.min.y,t.min.z,t.max.x,t.min.y,t.max.z,t.min.x,t.min.y,t.max.z,t.min.x,t.max.y,t.min.z,t.max.x,t.max.y,t.min.z,t.max.x,t.max.y,t.max.z,t.min.x,t.max.y,t.max.z]),o=new l.BufferGeometry;o.setIndex(new l.BufferAttribute(i,1)),o.setAttribute("position",new l.BufferAttribute(n,3)),super(o,new l.LineBasicMaterial({color:e}))}}class gt{constructor(t){this.node=t,this.next=null,this.previous=null}}class mt{constructor(t=1e6){this.pointBudget=t,this.first=null,this.last=null,this.numPoints=0,this.items=new Map}get size(){return this.items.size}has(t){return this.items.has(t.id)}touch(t){if(!t.loaded)return;const e=this.items.get(t.id);e?this.touchExisting(e):this.addNew(t)}addNew(t){const e=new gt(t);e.previous=this.last,this.last=e,e.previous&&(e.previous.next=e),this.first||(this.first=e),this.items.set(t.id,e),this.numPoints+=t.numPoints}touchExisting(t){t.previous?t.next&&(t.previous.next=t.next,t.next.previous=t.previous,t.previous=this.last,t.next=null,this.last=t,t.previous&&(t.previous.next=t)):t.next&&(this.first=t.next,this.first.previous=null,t.previous=this.last,t.next=null,this.last=t,t.previous&&(t.previous.next=t))}remove(t){const e=this.items.get(t.id);e&&(1===this.items.size?(this.first=null,this.last=null):(e.previous||(this.first=e.next,this.first.previous=null),e.next||(this.last=e.previous,this.last.next=null),e.previous&&e.next&&(e.previous.next=e.next,e.next.previous=e.previous)),this.items.delete(t.id),this.numPoints-=t.numPoints)}getLRUItem(){return this.first?this.first.node:void 0}freeMemory(){if(!(this.items.size<=1))for(;this.numPoints>2*this.pointBudget;){const t=this.getLRUItem();t&&this.disposeSubtree(t)}}disposeSubtree(t){const e=[t];t.traverse((t=>{t.loaded&&e.push(t)}));for(const t of e)t.dispose(),this.remove(t)}}class vt{constructor(t,e,i,n){this.pointCloudIndex=t,this.weight=e,this.node=i,this.parent=n}}class xt{constructor(){this._pointBudget=1e6,this._rendererSize=new l.Vector2,this.maxNumNodesLoading=4,this.features=it,this.lru=new mt(this._pointBudget),this.updateVisibilityStructures=(()=>{const t=new l.Matrix4,e=new l.Matrix4,i=new l.Matrix4;return(n,o)=>{const r=[],s=[],a=new pt.L((t=>1/t.weight));for(let d=0;d<n.length;d++){const c=n[d];if(!c.initialized())continue;c.numVisiblePoints=0,c.visibleNodes=[],c.visibleGeometry=[],o.updateMatrixWorld(!1);const u=o.matrixWorldInverse,h=c.matrixWorld;if(t.identity().multiply(o.projectionMatrix).multiply(u).multiply(h),r.push((new l.Frustum).setFromProjectionMatrix(t)),e.copy(h).invert(),i.identity().multiply(e).multiply(o.matrixWorld),s.push((new l.Vector3).setFromMatrixPosition(i)),c.visible&&null!==c.root){const t=Number.MAX_VALUE;a.push(new vt(d,t,c.root))}ht(c.root)&&c.hideDescendants(c.root.sceneNode);for(const t of c.boundingBoxNodes)t.visible=!1}return{frustums:r,cameraPositions:s,priorityQueue:a}}})()}loadPointCloud(t,e,i=((t,e)=>fetch(t,e))){return function(t,e,i){return Promise.resolve(e(t)).then((t=>i(t,{mode:"cors"}).then((t=>t.json())).then(function(t,e,i){return n=>{const{offset:o,boundingBox:r,tightBoundingBox:s}=function(t){const e=new l.Vector3(t.boundingBox.lx,t.boundingBox.ly,t.boundingBox.lz),i=new l.Vector3(t.boundingBox.ux,t.boundingBox.uy,t.boundingBox.uz),n=new l.Box3(e,i),o=n.clone(),r=e.clone();if(t.tightBoundingBox){const{lx:e,ly:i,lz:n,ux:r,uy:s,uz:a}=t.tightBoundingBox;o.min.set(e,i,n),o.max.set(r,s,a)}return n.min.sub(r),n.max.sub(r),o.min.sub(r),o.max.sub(r),{offset:r,boundingBox:n,tightBoundingBox:o}}(n),a=new dt({getUrl:e,version:n.version,boundingBox:r,scale:n.scale,xhrRequest:i}),d=new q(a,r,s,o,i);d.url=t,d.octreeDir=n.octreeDir,d.needsUpdate=!0,d.spacing=n.spacing,d.hierarchyStepSize=n.hierarchyStepSize,d.projection=n.projection,d.offset=o,d.pointAttributes=new k(n.pointAttributes);const c={},u=new rt(n.version);return function(t,e,i,n){const o=new K("r",t,t.boundingBox);return o.hasChildren=!0,o.spacing=t.spacing,n.upTo("1.5")?o.numPoints=e.hierarchy[0][1]:o.numPoints=0,t.root=o,i.r=o,t.root.load()}(d,n,c,u).then((()=>(u.upTo("1.4")&&function(t,e,i){for(let n=1;n<e.hierarchy.length;n++){const[o,r]=e.hierarchy[n],{index:s,parentName:a,level:l}=ct(o),d=i[a],c=X(d.boundingBox,s),u=new K(o,t,c);u.level=l,u.numPoints=r,u.spacing=t.spacing/Math.pow(2,u.level),i[o]=u,d.addChild(u)}}(d,n,c),d.nodes=c,d)))}}(t,e,i))))}(t,e,i).then((t=>new tt(this,t)))}updatePointClouds(t,e,i){const n=this.updateVisibility(t,e,i);for(let n=0;n<t.length;n++){const o=t[n];o.disposed||(o.material.updateMaterial(o,o.visibleNodes,e,i),o.updateVisibleBounds(),o.updateBoundingBoxes())}return this.lru.freeMemory(),n}static pick(t,e,i,n,o={}){return xt.picker=xt.picker||new Z,xt.picker.pick(e,i,n,t,o)}get pointBudget(){return this._pointBudget}set pointBudget(t){t!==this._pointBudget&&(this._pointBudget=t,this.lru.pointBudget=t,this.lru.freeMemory())}updateVisibility(t,e,i){let n=0;const o=[],r=[],{frustums:s,cameraPositions:a,priorityQueue:l}=this.updateVisibilityStructures(t,e);let d,c=0,u=!1,h=!1;for(;void 0!==(d=l.pop());){let p=d.node;if(n+p.numPoints>this.pointBudget)break;const f=d.pointCloudIndex,g=t[f],m=void 0!==g.maxLevel?g.maxLevel:1/0;if(p.level>m||!s[f].intersectsBox(p.boundingBox)||this.shouldClip(g,p.boundingBox))continue;n+=p.numPoints,g.numVisiblePoints+=p.numPoints;const v=d.parent;if(ut(p)&&(!v||ht(v)))if(p.loaded&&c<2)p=g.toTreeNode(p,v),c++;else{if(p.failed){h=!0;continue}p.loaded&&c>=2&&(u=!0),r.push(p),g.visibleGeometry.push(p)}ht(p)&&(this.updateTreeNodeVisibility(g,p,o),g.visibleGeometry.push(p.geometryNode));const x=.5*i.getSize(this._rendererSize).height*i.getPixelRatio();this.updateChildVisibility(d,l,g,p,a[f],e,x)}const p=Math.min(this.maxNumNodesLoading,r.length),f=[];for(let t=0;t<p;t++)f.push(r[t].load());return{visibleNodes:o,numVisiblePoints:n,exceededMaxLoadsToGPU:u,nodeLoadFailed:h,nodeLoadPromises:f}}updateTreeNodeVisibility(t,e,i){this.lru.touch(e.geometryNode);const n=e.sceneNode;n.visible=!0,n.material=t.material,n.updateMatrix(),n.matrixWorld.multiplyMatrices(t.matrixWorld,n.matrix),i.push(e),t.visibleNodes.push(e),this.updateBoundingBoxVisibility(t,e)}updateChildVisibility(t,e,i,n,o,r,s){const a=n.children;for(let l=0;l<a.length;l++){const d=a[l];if(null===d)continue;const u=d.boundingSphere,h=u.center.distanceTo(o),p=u.radius;let f=0;if(r.type===c){const t=r.fov*Math.PI/180;f=s/(Math.tan(t/2)*h)}else{const t=r;f=2*s/(t.top-t.bottom)}const g=p*f;if(g<i.minNodePixelSize)continue;const m=h<p?Number.MAX_VALUE:g+1/h;e.push(new vt(t.pointCloudIndex,m,d,n))}}updateBoundingBoxVisibility(t,e){if(t.showBoundingBox&&!e.boundingBoxNode){const i=new ft(e.boundingBox);i.matrixAutoUpdate=!1,t.boundingBoxNodes.push(i),e.boundingBoxNode=i,e.boundingBoxNode.matrix.copy(t.matrixWorld)}else t.showBoundingBox&&e.boundingBoxNode?(e.boundingBoxNode.visible=!0,e.boundingBoxNode.matrix.copy(t.matrixWorld)):!t.showBoundingBox&&e.boundingBoxNode&&(e.boundingBoxNode.visible=!1)}shouldClip(e,i){const n=e.material;if(0===n.numClipBoxes||n.clipMode!==t.CLIP_OUTSIDE)return!1;const o=i.clone();e.updateMatrixWorld(!0),o.applyMatrix4(e.matrixWorld);const r=n.clipBoxes;for(let t=0;t<r.length;t++){const e=r[t].matrix,i=new l.Box3(new l.Vector3(-.5,-.5,-.5),new l.Vector3(.5,.5,.5)).applyMatrix4(e);if(o.intersectsBox(i))return!1}return!0}}})(),o})()}));